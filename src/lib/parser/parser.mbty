// revision: b596cbbe0b642858aae4fe6947670712b6f16f8b

%derive<Show> Token
%position<@ast_types.Position>
%derive<Show> ParseError

%start structure
%start expression

%token<CharLiteral> CHAR
%token<String> INT
%token<CharLiteral> BYTE
%token<StringLiteral> BYTES
%token<String> FLOAT
%token<String> DOUBLE
%token<StringLiteral> STRING
%token<String> MULTILINE_STRING
%token<InterpLiteral> MULTILINE_INTERP
%token<InterpLiteral> INTERP
%token<(String, String?, String)> ATTRIBUTE
%token<String> LIDENT
%token<String> UIDENT
%token<String> POST_LABEL
%token<Comment> COMMENT
%token NEWLINE
%token<String> INFIX1
%token<String> INFIX2
%token<String> INFIX3
%token<String> INFIX4
%token<String> AUGMENTED_ASSIGNMENT
%token EOF
%token FALSE
%token TRUE
%token PUB "pub"
%token PRIV "priv"
%token READONLY "readonly"
%token IMPORT "import"
%token EXTERN "extern"
%token BREAK "break"
%token CONTINUE "continue"
%token STRUCT "struct"
%token ENUM "enum"
%token TRAIT "trait"
%token DERIVE "derive"
%token IMPL "impl"
%token WITH "with"
%token RAISE "raise"
%token THROW "throw"
%token TRY "try"
%token CATCH "catch"
%token ASYNC "async"
%token TYPEALIAS "typealias"
%token TRAITALIAS "traitalias"
%token FNALIAS "fnalias"
%token EQUAL "="
%token LPAREN "("
%token RPAREN ")"
%token COMMA ","
%token MINUS "-"
%token QUESTION "?"
%token EXCLAMATION "!"
%token<String> DOT_LIDENT
%token<String> DOT_UIDENT
%token<Int> DOT_INT
%token DOT_LPAREN ".("
%token COLONCOLON "::"
%token COLON ":"
%token<Bool> SEMI
%token LBRACKET "["
%token PLUS "+"
%token RBRACKET "]"
%token UNDERSCORE "_"
%token BAR "|"
%token LBRACE "{"
%token RBRACE "}"
%token AMPERAMPER "&&"
%token AMPER "&"
%token CARET "^"
%token BARBAR "||"
%token<String> PACKAGE_NAME
%token AS "as"
%token PIPE "|>"
%token ELSE "else"
%token FN "fn"
%token IF "if"
%token LET "let"
%token CONST "const"
%token MATCH "match"
%token USING "using"
%token MUTABLE "mut"
%token TYPE "type"
%token FAT_ARROW "=>"
%token THIN_ARROW "->"
%token WHILE "while"
%token RETURN "return"
%token DOTDOT ".."
%token RANGE_INCLUSIVE "..="
%token RANGE_EXCLUSIVE "..<"
%token ELLIPSIS "..."
%token TEST "test"
%token LOOP "loop"
%token GUARD "guard"
%token FOR "for"
%token IN "in"
%token IS "is"
%token SUBERROR "suberror"
%token AND "and"
%token LETREC "letrec"
%token ENUMVIEW "enumview"
%token NORAISE "noraise"

%right BARBAR
%right AMPERAMPER
%left BAR
%left CARET
%left AMPER
%nonassoc prec_field
%nonassoc LPAREN
%left INFIX1
%left INFIX2
%left PLUS MINUS
%left INFIX3
%left INFIX4
%nonassoc prec_lower_than_as
%nonassoc "as"
%nonassoc prec_apply_non_ident_fn
%nonassoc "!"
%nonassoc "?"
%nonassoc prec_lower_than_arrow_fn
%nonassoc ","
%nonassoc ")"
%nonassoc ":"

%%

// Helper rules for lists
non_empty_list_rev[T](X : T) -> @list.T[T]
  : X { @list.singleton($1) }
  | non_empty_list_rev(X) X { @list.Cons($2, $1) }
  ;

non_empty_list[T](X : T) -> @list.T[T] 
  : X { @list.singleton($1) }
  | X non_empty_list(X) { @list.Cons($1, $2) }
  ;

non_empty_list_commas_rev[T](X : T) -> @list.T[T]
  : X { @list.singleton($1) }
  | non_empty_list_commas_rev(X) "," X { @list.Cons($3, $1) }
  ;

non_empty_list_commas_no_trailing[T](X : T) -> @list.T[T]
  : X { @list.singleton($1) }
  | X "," non_empty_list_commas_no_trailing(X) { @list.Cons($1, $3) }
  ;

non_empty_list_commas[T](X : T) -> @list.T[T]
  : non_empty_list_commas_no_trailing(X) option(",") { $1 }
  ;

non_empty_list_commas_with_tail[T](X : T) -> @list.T[T]
  : non_empty_list_commas_no_trailing(X) "," { $1 }
  ;

list_commas[T](X : T) -> @list.T[T]
  : { Nil }
  | non_empty_list_commas(X) { $1 }
  ;

list_commas_no_trailing[T](X : T) -> @list.T[T]
  : { Nil }
  | non_empty_list_commas_no_trailing(X) { $1 }
  ;

non_empty_list_commas_with_trailing_info[T](X : T) -> (@list.T[T], Bool)
  : non_empty_list_commas_no_trailing(X) option(",") { 
    ($1, $2.is_some()) 
  }
  ;

list_commas_with_trailing_info[T](X : T) -> (@list.T[T], Bool)
  : { (Nil, false) }
  | non_empty_list_commas_with_trailing_info(X) { $1 }
  ;

non_empty_list_semi_rev_aux[T](X : T) -> @list.T[T]
  : X { @list.singleton($1) }
  | non_empty_list_semi_rev_aux(X) SEMI X { @list.Cons($3, $1) }
  ;

non_empty_list_semis_rev[T](X : T) -> @list.T[T]
  : non_empty_list_semi_rev_aux(X) option(SEMI) { $1 }
  ;

non_empty_list_semis[T](X : T) -> @list.T[T]
  : X option(SEMI) { @list.singleton($1) }
  | X SEMI non_empty_list_semis(X) { @list.Cons($1, $3) }
  ;

list_semis_rev[T](X : T) -> @list.T[T]
  : { Nil }
  | non_empty_list_semis_rev(X) { $1 }
  ;

list_semis[T](X : T) -> @list.T[T]
  : { Nil }
  | non_empty_list_semis(X) { $1 }
  ;

structure -> @list.T[Impl]
  : { ... }
  ;

expression -> Expr
  : { ... }
  ;